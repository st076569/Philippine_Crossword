#ifndef SOLVELIB_H
#define SOLVELIB_H

////////// solvelib //////////////////////////////////////////////////////////
// Автор    : Баталов Семен                                                 //
// Дата     : 08.11.2020                                                    //
// Описание : Здесь описан класс, который содержит в себе все необходимые   //
//            методы для решения филлипинского кроссворда.                  //
//////////////////////////////////////////////////////////////////////////////

#include "errlib.h"
#include "instrumentslib.h"

namespace pcs
{
    ////////// class Solver //////////////////////////////////////////////////
    // Класс, который содержит в себе все необходимые методы для решения    //
    // филлипинского кроссворда.                                            //
    //                                                                      //
    // Основные методы :                                                    //
    // 1) setField(...) :                                                   //
    //    Инициализирует игровое поле, используя аргумент.                  //
    // 2) isCorrectField() :                                                //
    //    Возвращает "true", если поле задано корректно (есть != 0 клетки,  //
    //    у каждой >= 2 клетки есть парная (причем достаточно близкая, и в  //
    //    которую возможно построить путь), размеры поля заданы корректно). //
    // 3) prepare() :                                                       //
    //    Готовит поле к обработке (обнуляет лишнее, заполняет клетки с 1   //
    //    и 2, выделяет нужный объем памяти для вспомогательных нужд, ищет  //
    //    все нетривиальные клетки >= 3 и записывает их в отдельный массив) //
    // 4) solve(...) :                                                      //
    //    Разводит случайным образом пути (из нетривиальных клеток) по полю //
    //    кроссворда.                                                       //
    // 5) setDirections() :                                                 //
    //    Устанавливает направления путей в каждой клетке (LEFT, RIGHT,     //
    //    VERTICAL, MIDDLE, NONE).                                          //
    // 6) getField(...) :                                                   //
    //    Копирует игровое поле в аргумент.                                 //
    //////////////////////////////////////////////////////////////////////////
    
    class Solver
    {
        private :
            
            Field                 map_;     // Рабочее поле кроссворда
            std::vector<Vector>   path_;    // Хранилище прошлых позиций
            std::vector<Area>     areas_;   // Рабочие зоны текущей клетки
            std::vector<TrackSeq> track_;   // Информация о сдвигах
            std::vector<Vector>   points_;  // Набор нетривиальных клеток
            std::vector<int16_t>  idArray_; // "id" путей в рабочих областях
            int16_t nAreas_;                // Кол-во точек - соседей
            int16_t nId_;                   // Кол-во "id" путей в "idArray_"
            
        public :
            
            // (1) Конструктор
            Solver();
            
            // (2) Конструктор копирования
            Solver(const Solver& solver) = default;
            
            // (3) Перегрузка оператора присваивания
            Solver& operator=(const Solver& solver) = default;
            
            ////////// Запись и считывание поля кроссворда ///////////////////
            
            // (4) Инициализирует поле кроссворда
            void setField(const Field& map);
            
            // (5) Возвращает поле
            void getField(Field& map) const;
            
            ////////// Процедуры подготовки и решения ////////////////////////
            
            // (6) Проверка (первичная) корректности задания поля
            bool isCorrectField();
            
            // (7) Подготавливает поле
            void prepare();
            
            // (8) Разводит пути на поле (если это удается)
            void solve(bool& wasSolved);
            
            // (9) Задает направления обхода путей (для вывода на экран)
            void setDirections();
            
            // (10) Освобождает выделенную память
            void clear();
            
            // (11) Деструктор
            ~Solver() = default;
            
        private :
            
            ////////// Создание рабочих и поисковых областей /////////////////
            
            // (1) Составляет область поиска соседей
            void createCheckingArea(Vector point, Area& curArea);
            
            // (2) Составляет рабочую область для двух точек
            void createWorkingArea(Vector p1, Vector p2, Area& curArea);
            
            // (3) Точки являются соседями?
            bool areRelatedPoints(Vector p1, Vector p2);
            
            // (4) Создает рабочие области для "point"
            void createWorkingAreas(Vector point);
            
            ////////// Построение и удаление путей ///////////////////////////
            
            // (5) Строит (по возможности) все пути
            void createAllPaths();
            
            // (6) Строит путь из точки "point"
            void createPath(Vector point);
            
            // (7) Создает новый путь из точки "point" в родственную точку
            void createAreaPath(Vector point, Area curArea, bool& wasCreated);
            
            // (8) Удаляет путь с началом в точке "point"
            void deletePath(Vector point);
            
            // (9) Удаляет путь с номером "id"
            void deletePath(int16_t id);
            
            // (10) Удаляет мешающий путь и добавляет его начало в стек 
            void deleteRandomPath(bool& wasDeleted);
            
            ////////// Анализ ситуации на поле ///////////////////////////////
            
            // (11) Возвращает количество непостроенных путей
            int16_t getMisPathNumber();
            
            ////////// Проверка корректности поля ////////////////////////////
            
            // (12) Проверяет наличие соседей точки "point"
            bool haveFriends(Vector point);
            
            // (13) Проверяет наличие соседей во всех клетках > 1
            bool isCorrectRelations();
            
            // (14) Проверить, что непустые клетки (>= 2) образуют пары
            bool isCorrectNumber();
            
            ////////// Вспомогательные методы ////////////////////////////////
            
            // (15) Устанавливает направление обхода в точке "point"
            void setDirection(Vector point);
            
            // (16) Находит предыдущую и следующую точки пути
            void findNear(Vector dot, bool& hL, bool& hR, bool& hU, bool& hD);
            
            // (17) Возвращает направление пути в точке по ее соседям
            Direction getDirection(bool hL, bool hR, bool hU, bool hD);
            
            // (18) Добавляет новый "id" в массив всех "id" области
            void addId(int16_t id);
            
            // (19) Добавляет "id" точки "curPoint" в список всех "id"
            void checkAddId(Vector point, Vector curPoint);
            
            // (20) Возвращает координаты точки с таким "protoId"
            Vector getPosition(int16_t id);
    };
}

#endif